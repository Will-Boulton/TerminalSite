@inject IJSRuntime jsRuntime
<div class="terminal">
    <div class="inputline">
        <div class="prompt">@Prompt</div>
        <input class="terminal input" @onkeyup="@KeyUp" @bind="command" spellcheck="false" disabled="@disabled" autofocus="@(!disabled)" @ref="input" />
    </div>
    @foreach (ITerminalResponse response in terminalResponses)
    {
        response.Render();
    }
</div>
@code {
    private static readonly string Prompt = @"$root # ";
    private static int key_ = 0;

    public int Key = key_++;

    [Parameter]
    public Terminal Parent { get;set; }

    public string command = "";
    private bool disabled = false;

    private ElementReference input;

    private TerminalOutput output;

    private List<ITerminalResponse> terminalResponses = new List<ITerminalResponse>();

    private void KeyUp(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            disabled = true;
            Sumbit(command);
        }

        if (e.Code == "ArrowUp")
        {
            commandIndex = Math.Max(commandIndex - 1,0);
            if (Parent.PreviousCommands.Count > 0)
                command = Parent.PreviousCommands[Parent.PreviousCommands.Count - commandIndex];
            else
            {
                command = string.Empty;
            }
            StateHasChanged();
        }
        else if (e.Code == "ArrowDown")
        {
            commandIndex = Math.Min(commandIndex + 1, Parent.PreviousCommands.Count - 1);
            if (Parent.PreviousCommands.Count > 0)
                command = Parent.PreviousCommands[Parent.PreviousCommands.Count - commandIndex];
            else
            {
                command = string.Empty;
            }
            StateHasChanged();
        }
    }

    private int commandIndex = 0;

    private void Sumbit(string value)
    {
        string[] split = value.Split(null);

        if(split.Length > 0)
        {
            string keyCommand = split[0].ToLower();

            Parent.RunCommand(keyCommand, output,split.Skip(1).ToArray());
        }

        if(!string.IsNullOrEmpty(value))
            Parent.PreviousCommands.Add(value);
        commandIndex = Parent.PreviousCommands.Count - 1;
        Parent.AddNew();
    }

    protected async override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !disabled)
        {
            await jsRuntime.InvokeVoidAsync("SetFocusToElement", input);
        }
    }

}
