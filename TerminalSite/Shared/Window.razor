@inject IJSRuntime JS

<div class="window_frame"
     style="position:absolute; top: @(offsetY)px; left: @(offsetX)px; width: @(Width)px; height: @(Height)px;" hidden="@(!ReadyToShow)"  @ref="@windowRef">
    <div class="title_bar" draggable="true" 
          @ondragstart="OnDragStart" @ondragend="OnDragEnd" @ondblclick="MaximiseOrUnmaximise"> 
        <div>@Title</div>
        <div class="button_div">
            @foreach (TitleButtonData item in TitleButtons)
            {
                <TitleBarButton Website="@item.Website" Link="@item.URL" />
            }
        </div>
    </div>
    <div class="window_content">
        @ChildContent
    </div>
</div>

@code {
    [Parameter]
    public string Title { get;set;}
    [Parameter]
    public RenderFragment ChildContent { get; set; }

    [Parameter]
    public int WindowDragPadding { get; set; } = 5;

    private List<TitleButtonData> TitleButtons;

    public double Width, Height = 0;

    private WindowDimension windowDims;

    private ElementReference windowRef;
    private bool ReadyToShow = false;
    protected override void OnInitialized()
    {
        Task.Run(() => SetInitialPos());
        base.OnInitialized();
        MakeTitleButtons();
    }

    /// <summary>
    /// Sets the inital position of the window inside the desktop
    /// </summary>
    /// <returns></returns>
    private async Task SetInitialPos()
    {
        windowDims = await getWindowDims();
        Width = 0.7 * windowDims.Width;
        Height = 0.7 * windowDims.Height;
        StateHasChanged();
        var result = await getBoundingClientRect(windowRef);
        offsetX = (windowDims.Width - result.Width) / 2;
        offsetY = (windowDims.Height - result.Height) / 2;
        ReadyToShow = true;
        StateHasChanged();
    }

    /// <summary>
    /// Get the dimesions of the user's viewport
    /// </summary>
    /// <returns></returns>
    private async Task<WindowDimension> getWindowDims()
    {
        return await JS.InvokeAsync<WindowDimension>("getWindowDimensions");
    }

    /// <summary>
    /// Get the bounding rectangle for an element
    /// </summary>
    /// <param name="refr">element</param>
    /// <returns></returns>
    private async Task<BoundingClientRect> getBoundingClientRect(ElementReference refr)
    {
        return await JS.InvokeAsync<BoundingClientRect>("getBoundingClientRect", new object[] { refr });
    }

    /// <summary>
    /// Put the title buttons in place on the taskbar
    /// </summary>
    private void MakeTitleButtons()
    {
        TitleButtons = new List<TitleButtonData>();

        var sites = SiteConfig.config.GetSection("Sites");
        foreach (var siteConfigItem in sites.GetChildren())
        {
            string url = siteConfigItem["URL"];

            string website = siteConfigItem["Website"];

            TitleButtons.Add(new TitleButtonData(website,url));
        }
    }

    private double prevWidth, prevHeight, prevOffsetX, prevOffsetY;
    private bool isMaximised = false;

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
         return base.OnAfterRenderAsync(firstRender);
    }

    /// <summary>
    /// Maximise the window if it isn't maximised and do the opposite if it is
    /// </summary>
    private async void MaximiseOrUnmaximise()
    {
        if (!isMaximised)
        {
            var result = await getBoundingClientRect(windowRef);
            prevWidth = result.Width;
            prevHeight = result.Height;
            prevOffsetX = offsetX;
            prevOffsetY = offsetY;
            Width = windowDims.Width - 2 * WindowDragPadding;
            Height = windowDims.Height - 2 * WindowDragPadding;
            offsetX = offsetY = WindowDragPadding;
        }
        else
        {
            Width = prevWidth;
            Height = prevHeight;
            offsetX = prevOffsetX;
            offsetY = prevOffsetY;
        }
        StateHasChanged();
        isMaximised = !isMaximised;
    }

    private double startX, startY, offsetX, offsetY;
    private void OnDragStart(DragEventArgs args)
    {
        startX = args.ClientX;
        startY = args.ClientY;
    }

    private async void OnDragEnd(DragEventArgs args)
    {
        var result = await getBoundingClientRect(windowRef);
        Width = result.Width;
        Height = result.Height;

        offsetX = Math.Min(Math.Max( offsetX  + (args.ClientX - startX), WindowDragPadding), windowDims.Width - Width - WindowDragPadding);
        offsetY = Math.Min(Math.Max( offsetY  + (args.ClientY - startY), WindowDragPadding), windowDims.Height - Height - WindowDragPadding);
        StateHasChanged();
    }
}
